{"ts":1360743357979,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360743418655,"patch":[[{"diffs":[[1," var express = require('express')\r\n , app = module.exports = express()\r\n  , silent = 'test' == process.env.NODE_ENV;\r\n\r\n// general config\r\napp.set('views', __dirname + '/views');\r\napp.set('view engine', 'jade');\r\n\r\n// our custom \"verbose errors\" setting\r\n// which we can use in the templates\r\n// via settings['verbose errors']\r\napp.enable('verbose errors');\r\n\r\n// disable them in production\r\n// use $ NODE_ENV=production node examples/error-pages\r\nif ('production' == app.settings.env) {\r\n  app.disable('verbose errors');\r\n}\r\n\r\napp.use(express.favicon());\r\n\r\nsilent || app.use(express.logger('dev'));\r\n\r\n// \"app.router\" positions our routes \r\n// above the middleware defined below,\r\n// this means that Express will attempt\r\n// to match & call routes _before_ continuing\r\n// on, at which point we assume it's a 404 because\r\n// no route has handled the request.\r\n\r\napp.use(app.router);\r\n\r\n// Since this is the last non-error-handling\r\n// middleware use()d, we assume 404, as nothing else\r\n// responded.\r\n\r\n// $ curl http://localhost:3000/notfound\r\n// $ curl http://localhost:3000/notfound -H \"Accept: application/json\"\r\n// $ curl http://localhost:3000/notfound -H \"Accept: text/plain\"\r\n\r\napp.use(function(req, res, next){\r\n  res.status(404);\r\n  \r\n  // respond with html page\r\n  if (req.accepts('html')) {\r\n    res.render('404', { url: req.url });\r\n    return;\r\n  }\r\n\r\n  // respond with json\r\n  if (req.accepts('json')) {\r\n    res.send({ error: 'Not found' });\r\n    return;\r\n  }\r\n\r\n  // default to plain-text. send()\r\n  res.type('txt').send('Not found');\r\n});\r\n\r\n// error-handling middleware, take the same form\r\n// as regular middleware, however they require an\r\n// arity of 4, aka the signature (err, req, res, next).\r\n// when connect has an error, it will invoke ONLY error-handling\r\n// middleware.\r\n\r\n// If we were to next() here any remaining non-error-handling\r\n// middleware would then be executed, or if we next(err) to\r\n// continue passing the error, only error-handling middleware\r\n// would remain being executed, however here\r\n// we simply respond with an error page.\r\n\r\napp.use(function(err, req, res, next){\r\n  // we may use properties of the error object\r\n  // here and next(err) appropriately, or if\r\n  // we possibly recovered from the error, simply next().\r\n  res.status(err.status || 500);\r\n  res.render('500', { error: err });\r\n});\r\n\r\n// Routes\r\n\r\napp.get('/', function(req, res){\r\n  res.render('index.jade');\r\n});\r\n\r\napp.get('/404', function(req, res, next){\r\n  // trigger a 404 since no other middleware\r\n  // will match /404 after this one, and we're not\r\n  // responding here\r\n  next();\r\n});\r\n\r\napp.get('/403', function(req, res, next){\r\n  // trigger a 403 error\r\n  var err = new Error('not allowed!');\r\n  err.status = 403;\r\n  next(err);\r\n});\r\n\r\napp.get('/500', function(req, res, next){\r\n  // trigger a generic (500) error\r\n  next(new Error('keyboard cat!'));\r\n});\r\n\r\nif (!module.parent) {\r\n  app.listen(3000);\r\n  silent || console.log('Express started on port 3000');\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":2992}]],"length":2992,"saved":false}
{"ts":1360743647943,"patch":[[{"diffs":[[0,".listen("],[-1,"3000"],[1,"process.env.PORT"],[0,");\r\n  si"]],"start1":2917,"start2":2917,"length1":20,"length2":32}]],"length":3004,"saved":false}
