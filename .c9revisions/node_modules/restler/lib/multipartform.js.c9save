{"ts":1360220356426,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var fs = require('fs');\nvar sys = require('util')\nexports.defaultBoundary = '48940923NODERESLTER3890457293';\n\n\n// This little object allows us hijack the write method via duck-typing\n// and write to strings or regular streams that support the write method.\nfunction Stream(stream) {\n\t//If the user pases a string for stream,we initalize one to write to\n\tif (this._isString(stream)) {\n\t\tthis.string = \"\";\n\t}\n\tthis.stream = stream;\n\t\n}\n\nStream.prototype = {\n  //write to an internal String or to the Stream\n  write: function(data) {\n\tif (this.string != undefined) {\n\t\tthis.string += data;\n\t} else {\n\t\tthis.stream.write(data, \"binary\");\n\t}\n  },\n\n  //stolen from underscore.js\n  _isString: function(obj) {\n    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));\n  }\n}\n\nfunction File(path, filename, fileSize, encoding, contentType) {\n  this.path = path;\n  this.filename = filename || this._basename(path);\n  this.fileSize = fileSize;\n  this.encoding = encoding || \"binary\";\n  this.contentType = contentType || 'application/octet-stream';\n}\n\nFile.prototype = {\n  _basename: function(path) {\n    var parts = path.split(/\\/|\\\\/);\n    return parts[parts.length - 1];\n  }\n};\n\nfunction Data(filename, contentType, data) {\n  this.filename = filename;\n  this.contentType = contentType || 'application/octet-stream';\n  this.data = data;\n}\n\nfunction Part(name, value, boundary) {\n  this.name = name;\n  this.value = value;\n  this.boundary = boundary;\n}\n\n\nPart.prototype = {\n\t\n  //returns the Content-Disposition header\t\t\n  header: function() {\n\t  var header;\n\t  \n    if (this.value.data) {\n\t    header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \n  \t            \"\\\"; filename=\\\"\" + this.value.filename + \"\\\"\\r\\n\" +\n  \t            \"Content-Type: \" + this.value.contentType;\n \t  } if (this.value instanceof File) {\n  \t  header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \n  \t            \"\\\"; filename=\\\"\" + this.value.filename + \"\\\"\\r\\n\" +\n  \t            \"Content-Length: \" + this.value.fileSize + \"\\r\\n\" +\t\n  \t            \"Content-Type: \" + this.value.contentType;\t\n  \t} else {\n      header = \"Content-Disposition: form-data; name=\\\"\" + this.name + \"\\\"\";\n  \t}\n  \t\n\t  return \"--\" + this.boundary + \"\\r\\n\" + header + \"\\r\\n\\r\\n\";\n  },\n\n  //calculates the size of the Part\n  sizeOf: function() {\n\t  var valueSize;\n  \tif (this.value instanceof File) {\n  \t  valueSize = this.value.fileSize;\n  \t} else if (this.value.data) {\n  \t  valueSize = this.value.data.length;\n        } else if (typeof this.value === 'number') {\n          valueSize = this.value.toString().length;\n  \t} else {\n  \t  valueSize = this.value.length;\n  \t}\n  \treturn valueSize + this.header().length + 2; \n  },\n\n  // Writes the Part out to a writable stream that supports the write(data) method\n  // You can also pass in a String and a String will be returned to the callback\n  // with the whole Part\n  // Calls the callback when complete\n  write: function(stream, callback) {\n\t\n    var self = this;\n\t\n\t  //first write the Content-Disposition\n\t  stream.write(this.header());\n\t\n  \t//Now write out the body of the Part\n    if (this.value instanceof File) {\n  \t  fs.open(this.value.path, \"r\", 0666, function (err, fd) { \n    \t  if (err) throw err; \n    \t  \n  \t\t  var position = 0;\n  \t\t  \n  \t    (function reader () {\n  \t      fs.read(fd, 1024 * 4, position, \"binary\", function (er, chunk) {\n  \t        if (er) callback(err);\n  \t        stream.write(chunk); \n  \t        position += 1024 * 4;\n  \t        if (chunk) reader();\n  \t        else {\n  \t\t\t      stream.write(\"\\r\\n\")\n      \t\t\t  callback();\n      \t\t\t  fs.close(fd);\n      \t\t\t}\n  \t      }); \n  \t    })(); // reader() \n  \t  });\n     } else {\n  \t  stream.write(this.value + \"\\r\\n\");\n  \t  callback();\n  \t}\n  }\n}\n\n//Renamed to MultiPartRequest from Request\nfunction MultiPartRequest(data, boundary) {\n  this.encoding = 'binary';\n  this.boundary = boundary || exports.defaultBoundary;\n  this.data = data;\n  this.partNames = this._partNames();\n}\n\nMultiPartRequest.prototype = {\n  _partNames: function() {\n    var partNames = [];\n    for (var name in this.data) {\n      partNames.push(name)\n  \t}\n  \treturn partNames;\n  },\n  \n  write: function(stream, callback) {\n    var partCount = 0, self = this;\n    \n\t  // wrap the stream in our own Stream object\n  \t// See the Stream function above for the benefits of this\n  \tvar stream = new Stream(stream);\n  \t\n  \t// Let each part write itself out to the stream\n  \t(function writePart() {\n  \t  var partName = self.partNames[partCount];\n  \t  var part = new Part(partName, self.data[partName], self.boundary);\n  \t  part.write(stream, function (err) {\n  \t\t  if (err) {\n    \t\t\tcallback(err);\n    \t\t\treturn;\n    \t\t}\n     \t\tpartCount += 1;\n    \t  if (partCount < self.partNames.length)\n    \t    writePart();\n    \t\telse {\n    \t\t  stream.write('--' + self.boundary + '--' + \"\\r\\n\");\n\n          if (callback) callback(stream.string || \"\");\n    \t\t}\n  \t  });\n    })(); \n  }\n}\n\nvar exportMethods = {\n  file: function(path, filename, fileSize, encoding, contentType) { \n    return new File(path, filename, fileSize, encoding, contentType)\n  },\n  data: function(filename, contentType, data) {\n    return new Data(filename, contentType, data);\n  },\n  sizeOf: function(parts, boundary) {\n    var totalSize = 0;\n\t  boundary = boundary || exports.defaultBoundary;\n  \tfor (var name in parts) totalSize += new Part(name, parts[name], boundary).sizeOf();\n  \treturn totalSize + boundary.length + 6;\n  },\n  write: function(stream, data, callback, boundary) {\n    var r = new MultiPartRequest(data, boundary);\n    r.write(stream, callback);\n    return r;\n  }\n}\n\nObject.keys(exportMethods).forEach(function(exportMethod) {\n  exports[exportMethod] = exportMethods[exportMethod]\n})\n"]],"start1":0,"start2":0,"length1":0,"length2":5724}]],"length":5724}
